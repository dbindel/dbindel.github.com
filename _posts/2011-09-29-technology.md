---
layout:     post
title:      Technology and teaching
tags: [technology, teaching]
---

Our department does not currently offer courses on iPhone programming,
or on building web frameworks with Django, on AJAX or HTML5, or on any of 
a plethora of new programming languages and frameworks that come and go
each month.  Even if we had the staff available to teach such courses,
it's not clear to what extent we would want to do so.  The technology
du jour often has a short half-life, and we are not doing anyone a service
if we teach skills that are too narrow to continue to be useful for many
years after they are learned.

This topic came up in a recent faculty discussion, but it has stayed with
me over the past couple days as I think ahead to the coming lectures in
my parallel computing class.  I would like to think that this course has
value because it offers students a framework for understanding serial and
parallel performance, along with many examples of how to think about the
complex interactions between hardware, software, and numerical algorithms
in the process of designing high-performance numerical codes.  But at the
same time, I *do* teach technologies, even if many of them have been around
for a while.  When I've taught this material in the past, I've always had a few
students who were very pleased to tell me that my class is where they learned
about Makefiles or gnuplot or some other piece of UNIX lore.  And I often think
to myself that I would rather here how much they got out of the higher-level
ideas in the class.

But... I'm also glad that they feel happy about learning *something*, and I do
think there's great value to learning some of these tools.  The details of a
given tool are not so important as the realization that these tools exist, and
can be used to do wonderful things in the right hands.  Learning UNIX means
learning about how to cobble together an endless diversity of useful tools
out of small, flexible commands; learning to use a profiler means gaining a
deeper understanding of where our mental models of performance can go wrong;
and learning about C pointer-chasing provides a valuable lesson in thinking 
about levels of indirection.  Done right, teaching technologies *is* about
teaching ideas.  It's as much about understanding that a thing can be done
as about understanding all the grotty details used to do it.

And, of course, some of us enjoy the grotty details far too much ourselves
to steer our students away from the pleasure of digging into them.
